generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                String                  @id @default(uuid())
  name              String
  email             String                  @unique
  passwordHash      String
  createdAt         DateTime                @default(now())
  trialStart        DateTime?               @default(now())
  trialEnd          DateTime?
  planStatus        String                  @default("TRIAL")
  isActive          Boolean                 @default(true)
  companyName       String?
  primaryColor      String?                 @default("#22c55e")
  avatarUrl         String?
  preferredTheme    String                  @default("light")
  preferredLanguage String                  @default("pt")
  role              String                  @default("OWNER")
  companyId         String?
  whatsappNumber    String?
  contactPhone      String?
  reviewLinks       String?
  companyWebsite    String?
  companyShowcase   String?
  
  // Payment method configuration
  zelleEmail           String?
  venmoUsername        String?
  cashAppUsername      String?
  stripeAccountId      String?
  stripeConnected      Boolean                 @default(false)
  enabledPaymentMethods String?                // JSON array: ["ZELLE", "VENMO", "STRIPE"]
  businessLogo         String?                 // Cloudinary URL
  paymentInstructions  String?                 // Custom instructions for cash payments
  
  company           User?                   @relation("CompanyMembers", fields: [companyId], references: [id])
  teamMembers       User[]                  @relation("CompanyMembers")
  appointments      Appointment[]           @relation("AppointmentOwner")
  assignedVisits    Appointment[]           @relation("AppointmentAssignedHelper")
  checklistMarked   AppointmentChecklistItem[] @relation("ChecklistCompletedBy")
  uploadedPhotos    AppointmentPhoto[]      @relation("PhotoUploadedBy")
  customers         Customer[]
  transactions      Transaction[]
  contractsOwned    Contract[]              @relation("OwnerContracts")
  contractsSigned   Contract[]              @relation("ClientContracts")
  servicePackages   ServicePackage[]
  helperPayoutMode  String                  @default("FIXED")
  helperPayoutValue Float                   @default(0)
  helperExpenses    HelperExpense[]         @relation("HelperExpenses")
  recordedExpenses  HelperExpense[]         @relation("OwnerExpenses")
  pushSubscriptions PushSubscription[]
  googleAccessToken String?
  googleRefreshToken String?
  googleTokenExpiry DateTime?
  googleCalendarId  String?
  twilioNumbers     TwilioNumber[]
  conversations     Conversation[]
}

model Customer {
  id           String        @id @default(uuid())
  userId       String
  name         String
  email        String?
  phone        String?
  phoneE164    String?       @map("phone_e164")
  smsOptOut    Boolean       @default(false) @map("sms_opt_out")
  address      String?
  latitude     Float?
  longitude    Float?
  serviceType  String?
  notes        String?
  status       String        @default("ACTIVE")
  defaultPrice Float?
  clientPreferences String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  accessToken  String?       @unique
  appointments Appointment[]
  conversations Conversation[]
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([phoneE164])
}

model Appointment {
  id                       String                     @id @default(uuid())
  userId                   String
  customerId               String
  assignedHelperId         String?
  date                     DateTime
  startTime                String
  endTime                  String?
  price                    Float
  helperFee                Float?                    @default(0)
  status                   String                     @default("AGENDADO")
  isRecurring              Boolean                    @default(false)
  recurrenceRule           String?
  notes                    String?
  startedAt                DateTime?
  finishedAt               DateTime?
  estimatedDurationMinutes Int?
  invoiceNumber            String?
  invoiceToken             String?                    @unique
  invoiceSentAt            DateTime?
  recurrenceSeriesId       String?
  checklistSnapshot        String?
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @updatedAt
  customer                 Customer                   @relation(fields: [customerId], references: [id], onDelete: Cascade)
  owner                    User                      @relation("AppointmentOwner", fields: [userId], references: [id], onDelete: Cascade)
  assignedHelper           User?                     @relation("AppointmentAssignedHelper", fields: [assignedHelperId], references: [id])
  transactions             Transaction[]
  checklistItems           AppointmentChecklistItem[]
  photos                   AppointmentPhoto[]
  googleEventId            String?

  @@index([recurrenceSeriesId])
  @@index([assignedHelperId])
  @@index([googleEventId])
}

model HelperExpense {
  id        String   @id @default(uuid())
  helperId  String
  ownerId   String
  date      DateTime @default(now())
  category  String
  amount    Float
  notes     String?
  helper    User     @relation("HelperExpenses", fields: [helperId], references: [id], onDelete: Cascade)
  owner     User     @relation("OwnerExpenses", fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([helperId, date])
  @@index([ownerId, date])
}

model Contract {
  id           String    @id @default(uuid())
  ownerId      String
  clientId     String
  title        String
  body         String
  pdfUrl       String?
  status       String    @default("PENDENTE")
  sentAt       DateTime  @default(now())
  acceptedAt   DateTime?
  clientNotes  String?
  ownerNotes   String?
  placeholders String?
  gallery      String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  owner        User     @relation("OwnerContracts", fields: [ownerId], references: [id], onDelete: Cascade)
  client       User     @relation("ClientContracts", fields: [clientId], references: [id], onDelete: Cascade)
  servicePackageId String?
  servicePackage ServicePackage? @relation(fields: [servicePackageId], references: [id])
  customItems  String?   // JSON string of custom checklist items
  proposalStatus String  @default("DRAFT") // DRAFT, SENT, VIEWED, ACCEPTED, REJECTED
  
  @@index([ownerId, clientId, status])
}

model ServicePackage {
  id          String   @id @default(uuid())
  ownerId     String
  name        String
  description String?
  price       Float    @default(0)
  items       String   // JSON string of included items e.g., ["Dusting", "Vacuuming"]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  contracts   Contract[]
  
  @@index([ownerId])
}

model Transaction {
  id            String       @id @default(uuid())
  userId        String
  appointmentId String?
  type          String
  status        String
  amount        Float
  dueDate       DateTime
  paidAt        DateTime?
  description   String?
  createdAt     DateTime     @default(now())
  
  // Payment tracking fields
  invoiceToken         String?  @unique
  paymentLink          String?  // Stripe payment link URL (if Stripe used)
  paymentLinkId        String?  // Stripe payment link ID
  paymentMethod        String?  // 'ZELLE', 'VENMO', 'CASH_APP', 'STRIPE', 'CASH'
  stripeSessionId      String?  // Stripe checkout session ID
  paymentMetadata      String?  // JSON with payment details
  
  // Customer confirmation workflow
  customerMarkedPaid   Boolean  @default(false)
  customerPaidAt       DateTime?
  confirmationNotes    String?  // Customer's payment confirmation notes
  
  appointment   Appointment? @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([appointmentId, type])
}

model AppointmentChecklistItem {
  id             String      @id @default(uuid())
  appointmentId  String
  title          String
  sortOrder      Int         @default(0)
  completedAt    DateTime?
  completedById  String?
  appointment    Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  completedBy    User?       @relation("ChecklistCompletedBy", fields: [completedById], references: [id])
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  @@index([appointmentId])
}

model AppointmentPhoto {
  id             String                @id @default(uuid())
  appointmentId  String
  uploadedById   String?
  url            String
  type           String
  createdAt      DateTime              @default(now())
  appointment    Appointment           @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  uploadedBy     User?                 @relation("PhotoUploadedBy", fields: [uploadedById], references: [id])

  @@index([appointmentId])
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Add these models to the END of your schema.prisma file

model TwilioNumber {
  id              String    @id @default(uuid())
  phoneNumber     String    @unique @map("phone_number")
  isShared        Boolean   @default(true) @map("is_shared")
  userId          String?   @map("user_id")
  user            User?     @relation(fields: [userId], references: [id])
  createdAt       DateTime  @default(now()) @map("created_at")
  
  @@map("twilio_numbers")
}

model Conversation {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  user            User      @relation(fields: [userId], references: [id])
  customerId      String    @map("customer_id")
  customer        Customer  @relation(fields: [customerId], references: [id])
  status          String    @default("ACTIVE")
  messages        Message[]
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  @@index([userId, customerId])
  @@map("conversations")
}

model Message {
  id                    String       @id @default(uuid())
  conversationId        String       @map("conversation_id")
  conversation          Conversation @relation(fields: [conversationId], references: [id])
  direction             String       // INBOUND, OUTBOUND
  body                  String
  providerMessageSid    String       @unique @map("provider_message_sid")
  status                String       // QUEUED, SENT, DELIVERED, FAILED, RECEIVED
  errorCode             Int?         @map("error_code")
  createdAt             DateTime     @default(now()) @map("created_at")
  
  @@index([providerMessageSid])
  @@index([conversationId, createdAt])
  @@map("messages")
}

model InboundRouterLink {
  id              String    @id @default(uuid())
  phoneE164       String    @unique @map("phone_e164")
  userId          String    @map("user_id")
  confidence      String    // HIGH, MEDIUM
  source          String    // UNIQUE_MATCH, MANUAL_RESOLUTION
  createdAt       DateTime  @default(now()) @map("created_at")
  
  @@index([phoneE164])
  @@map("inbound_router_links")
}

model InboundConflict {
  id                    String    @id @default(uuid())
  fromPhone             String    @map("from_phone")
  toPhone               String    @map("to_phone")
  candidateUserIds      String    @map("candidate_user_ids") // JSON array as string
  messagePreview        String    @map("message_preview")
  reason                String
  status                String    @default("PENDING")
  resolvedUserId        String?   @map("resolved_user_id")
  createdAt             DateTime  @default(now()) @map("created_at")
  
  @@index([status, createdAt])
  @@map("inbound_conflicts")
}
